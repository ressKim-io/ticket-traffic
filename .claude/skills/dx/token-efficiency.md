# Token & Context Efficiency

Claude Code 세션에서 토큰 낭비를 줄이고 컨텍스트 윈도우를 효율적으로 사용하는 패턴

## Quick Reference (결정 트리)

```
파일 내용이 필요한가?
    │
    ├─ 줄 수만 필요 ──────────> wc -l (Bash)
    │
    ├─ 특정 구간만 필요 ──────> Read(offset, limit) 또는 head/tail
    │
    ├─ 구조/패턴 파악 ────────> head -20 또는 Grep(pattern)
    │
    ├─ 전체 내용 필요 ────────> Read 1회 (중복 읽기 금지)
    │
    └─ 수정이 필요 ──────────> Read 1회 → Edit (Read-back 불필요)


검색이 필요한가?
    │
    ├─ 파일명/경로 찾기 ──────> Glob
    │
    ├─ 코드 내 문자열 ────────> Grep
    │
    ├─ 구조적 탐색 ──────────> Task(Explore agent)
    │
    └─ 외부 정보 필요 ────────> WebSearch (3-4회 이내)


Agent 위임할까?
    │
    ├─ 단순 1-2개 파일 수정 ──> 직접 처리
    │
    ├─ 탐색 + 이해 필요 ─────> Task(Explore agent)
    │
    ├─ 독립적 다수 작업 ─────> Task 병렬 실행
    │
    └─ 복잡한 코드 작성 ─────> Task(general-purpose) + 줄 수 예산
```

---

## CRITICAL: Context Window 관리

### 컨텍스트 윈도우 구조

```
┌──────────────────────────────────────────────┐
│              Context Window (~200K)            │
├──────────────────────────────────────────────┤
│                                                │
│  ┌──────────────────────┐                     │
│  │ System Prompt        │ ~5-10K              │
│  │ (CLAUDE.md, rules)   │                     │
│  └──────────────────────┘                     │
│                                                │
│  ┌──────────────────────┐                     │
│  │ Conversation History │ 누적 증가           │
│  │ (모든 메시지)         │                     │
│  └──────────────────────┘                     │
│                                                │
│  ┌──────────────────────┐                     │
│  │ Tool Results         │ ← 가장 큰 비중     │
│  │ (Read, Grep, Bash)   │    여기를 줄여야!  │
│  └──────────────────────┘                     │
│                                                │
│  ┌──────────────────────┐                     │
│  │ Response Generation  │ ~4K                  │
│  └──────────────────────┘                     │
└──────────────────────────────────────────────┘
```

### 세션 비용 인식

```
작업 유형별 토큰 사용량 (실측치 기반 추정):

파일 Read (500줄)        ≈ 3-5K tokens
파일 Read (200줄)        ≈ 1-2K tokens
wc -l 결과               ≈ 50 tokens
head -20 결과            ≈ 200 tokens
Grep 결과 (10 matches)  ≈ 500 tokens
WebSearch 1회            ≈ 2-3K tokens
Agent 위임 1회           ≈ 프롬프트 크기 + 결과
Auto-compact 1회         ≈ 8K tokens (요약 비용)
```

### 핵심 원칙

```
1. 도구 결과 최소화 = 컨텍스트 절약
2. 한 번에 올바르게 = 반복 루프 방지
3. 필요한 만큼만 = 최소 정보 원칙
```

---

## 파일 읽기 최적화

### 목적별 최적 도구 선택

```
┌────────────────────────────┬─────────────────────────┬──────────┐
│ 목적                       │ 최적 방법               │ 토큰 비용│
├────────────────────────────┼─────────────────────────┼──────────┤
│ 줄 수 확인                 │ wc -l file.py           │ ~50      │
│ 파일 존재 여부             │ ls file.py              │ ~30      │
│ 구조/시작 부분 파악        │ Read(limit=20)          │ ~200     │
│ 특정 함수/클래스만         │ Read(offset, limit)     │ ~300     │
│ 패턴 존재 여부             │ Grep(pattern)           │ ~500     │
│ 전체 내용 이해 + 수정      │ Read → Edit             │ ~3-5K    │
│ 전체 내용 이해만           │ Read (1회)              │ ~3-5K    │
└────────────────────────────┴─────────────────────────┴──────────┘
```

### 올바른 패턴

```bash
# 줄 수만 확인
wc -l src/main.py          # ✅ ~50 tokens

# 특정 구간만 읽기
Read(file, offset=100, limit=30)  # ✅ 100-130줄만

# 파일 시작 부분만 확인
Read(file, limit=20)        # ✅ 처음 20줄만

# 수정 필요 시: 1회 읽기 → Edit
Read(file)                   # ✅ 1회
Edit(file, old, new)         # ✅ 수정
# Read-back 불필요!
```

### 금지 패턴

```bash
# ❌ 줄 수 확인에 전체 파일 읽기
Read(file)  # 500줄 전체 읽어서 줄 수 세기

# ❌ 같은 파일 반복 읽기
Read(file)   # 1회차
# ... 작업 ...
Read(file)   # 2회차 (동일 파일!)
# ... 작업 ...
Read(file)   # 3회차 (동일 파일!)

# ❌ Write 후 전체 Read-back
Write(file, content)
Read(file)   # 방금 쓴 내용을 다시 전체 읽기
```

---

## Agent 위임 최적화

### 위임 전 규칙

```
┌───────────────────────────────────────────────────────────┐
│ Agent 위임 전 체크리스트                                   │
├───────────────────────────────────────────────────────────┤
│                                                            │
│ ✅ DO                          ❌ DON'T                    │
│ ─────────                      ──────────                  │
│ 파일 경로만 전달                대상 파일 미리 전체 읽기   │
│ 줄 수 예산 명시                 "알아서 작성해줘"          │
│ 결과 형식 지정                  파일 내용 프롬프트에 복붙  │
│ 독립 작업은 병렬 실행           하나씩 순차 위임           │
│ 구체적 지시사항                 모호한 요청                │
│                                                            │
└───────────────────────────────────────────────────────────┘
```

### 프롬프트 작성 패턴

```markdown
# 좋은 위임 프롬프트 (경로 + 제약 + 형식)
"src/services/auth.ts에 JWT 검증 미들웨어를 추가해줘.
- 450줄 이내로 작성
- 기존 패턴(src/services/user.ts) 참고
- 코드만 작성, 설명 불필요"

# 나쁜 위임 프롬프트 (모호 + 파일 내용 복붙)
"다음 파일을 수정해줘:
[500줄짜리 파일 내용 전체 복붙]
여기에 뭔가 추가해줘"
```

### 병렬 실행 최적화

```
독립적인 작업은 반드시 동시 실행:

# ✅ 병렬 실행 (1 turn에 모두)
Task(Explore, "auth 구조 파악")     ─┐
Task(Explore, "database 구조 파악")  ├─ 동시 실행
Task(Explore, "API 엔드포인트 파악") ─┘

# ❌ 순차 실행 (3 turns 소비)
Task(Explore, "auth 구조 파악")      → 완료 대기
Task(Explore, "database 구조 파악")  → 완료 대기
Task(Explore, "API 엔드포인트 파악") → 완료 대기
```

---

## 파일 쓰기 최적화

### Write vs Edit 선택

```
┌────────────────────────┬──────────┬──────────────────────┐
│ 상황                   │ 도구     │ 이유                 │
├────────────────────────┼──────────┼──────────────────────┤
│ 새 파일 생성           │ Write    │ 전체 내용 작성 필요  │
│ 기존 파일 부분 수정    │ Edit     │ 변경 부분만 전송     │
│ 기존 파일 대규모 변경  │ Write    │ Edit 여러 번보다 효율│
│ 설정 값 하나 변경      │ Edit     │ 최소 변경            │
└────────────────────────┴──────────┴──────────────────────┘
```

### Write 후 검증 패턴

```bash
# ✅ 올바른 검증
Write(file, content)
wc -l file                  # 줄 수 확인 (~50 tokens)
head -5 file                # 시작 부분 확인 (~100 tokens)
tail -5 file                # 끝 부분 확인 (~100 tokens)

# ❌ 과도한 검증
Write(file, content)
Read(file)                  # 전체 다시 읽기 (~3-5K tokens 낭비)
```

### 반복 수정 루프 방지

```
Write → Read → 문제 발견 → Write → Read → 문제 발견 → Write...

이 루프는 세션에서 가장 큰 토큰 낭비 원인 (~108K tokens 실측).

방지 전략:
1. Write 전에 내용을 충분히 계획
2. 한 번에 올바른 내용 작성
3. 검증은 wc -l + head/tail로만
4. 문제 발견 시 Edit로 부분 수정 (전체 Rewrite 아님)
```

---

## 검색 최적화

### 도구별 최적 용도

```
┌──────────────┬──────────────────────────┬──────────────────┐
│ 도구         │ 최적 용도                │ 토큰 비용        │
├──────────────┼──────────────────────────┼──────────────────┤
│ Glob         │ 파일명/경로 패턴 찾기    │ ~100-300         │
│ Grep         │ 코드 내 문자열 검색      │ ~300-1K          │
│ Explore agent│ 코드 구조 이해/탐색      │ ~2-5K            │
│ WebSearch    │ 외부 API/라이브러리 정보  │ ~2-3K/회         │
│ WebFetch     │ 특정 URL 내용 확인       │ ~3-5K            │
└──────────────┴──────────────────────────┴──────────────────┘
```

### WebSearch 효율화

```
# ✅ 타겟 검색 (3-4회)
WebSearch("Next.js 15 app router middleware")
WebSearch("Prisma 6 migration guide 2026")
WebSearch("Vitest v3 snapshot testing")

# ❌ 광범위 검색 (7-10회)
WebSearch("Next.js")
WebSearch("Next.js app router")
WebSearch("Next.js middleware")
WebSearch("Next.js middleware example")
WebSearch("Next.js middleware best practices")
WebSearch("Next.js middleware 2026")
WebSearch("Next.js 15 changes")
# → 같은 정보를 반복 검색, ~20K tokens 낭비
```

### 코드베이스 검색 전략

```
# ✅ 효율적 탐색
1. Glob("**/*.ts") → 파일 목록 파악
2. Grep("export function", type="ts") → 함수 목록
3. Read(specific_file) → 필요한 파일만 읽기

# ✅ 구조적 탐색이 필요하면
Task(Explore, "auth 시스템이 어떻게 구현되어 있는지 파악해줘")

# ❌ 비효율적 탐색
Read(file1)  # 관련 없을 수도 있는 파일
Read(file2)  # 관련 없을 수도 있는 파일
Read(file3)  # 관련 없을 수도 있는 파일
Grep(pattern1)  # 넓은 범위
Grep(pattern2)  # 또 넓은 범위
```

---

## 프롬프트 엔지니어링 (토큰 효율)

### 출력 제어

```markdown
# 출력량을 제한하는 지시사항

"코드만 작성해주세요. 설명 불필요."
→ 불필요한 설명 텍스트 절약

"핵심 3줄로 요약해주세요."
→ 장황한 분석 방지

"변경된 부분만 보여주세요."
→ 전체 파일 출력 방지

"Yes/No로만 답변해주세요."
→ 판단만 필요한 경우
```

### 제약 조건 명시

```markdown
# 명확한 제약 = 효율적 결과

"450줄 이내로 작성"        → 과도한 코드 생성 방지
"테스트 파일 3개 이내"      → 불필요한 테스트 방지
"기존 패턴 따르기"          → 스타일 탐색 시간 절약
"src/ 디렉토리만 수정"      → 범위 한정
```

---

## Anti-Patterns (낭비 패턴 테이블)

| 낭비 패턴 | 추정 토큰 비용 | 올바른 방법 | 절약량 |
|-----------|---------------|-------------|--------|
| Agent 위임 전 대상 파일 전체 읽기 | ~43K/세션 | `wc -l`로 줄 수만 확인, 경로만 전달 | ~90% |
| Write 후 전체 Read-back 반복 | ~108K/세션 | `wc -l` + `head`/`tail`로 검증 | ~95% |
| 동일 파일 N회 중복 읽기 | ~12K/세션 | 1회 Read + Edit 패턴 사용 | ~80% |
| 광범위 WebSearch 7-10회 | ~35K/세션 | 타겟 검색 3-4회 | ~60% |
| Agent에 파일 전체 내용 복붙 | ~20K/세션 | 파일 경로만 전달 (agent가 직접 읽음) | ~90% |
| `wc -l`로 충분한데 전체 Read | ~35K/세션 | `wc -l` 사용 | ~99% |
| `set -e`에서 `((var++))` 사용 | 디버깅 비용 | `var=$((var + 1))` 사용 | 오류 방지 |
| 순차적 독립 Agent 실행 | 대기 시간 | 병렬 Task 실행 | ~50% 시간 |

### 실측 사례 (세션 분석 결과)

```
총 토큰 사용량: ~600K tokens
불필요 소비량:  ~243K tokens (40.5%)

내역:
- Write→Read→Rewrite 반복 루프    ~108K (44%)
- 위임 전 불필요 파일 전체 읽기   ~43K  (18%)
- wc -l로 충분한데 전체 Read       ~35K  (14%)
- 과다 WebSearch                   ~35K  (14%)
- 동일 파일 중복 읽기              ~12K  (5%)
- 기타                             ~10K  (4%)
```

---

## Bash 명령어 효율 팁

### `set -e` 환경에서 주의

```bash
# ❌ set -e에서 오류 발생 (종료 코드 문제)
((count++))          # count가 0이면 종료 코드 1 → set -e로 스크립트 종료

# ✅ 안전한 산술 증가
count=$((count + 1))

# ❌ 파일 카운트를 위해 전체 내용 읽기
content=$(cat large_file.txt)
echo "$content" | wc -l

# ✅ 직접 줄 수 세기
wc -l < large_file.txt
```

### 병렬 명령 실행

```bash
# ✅ 독립적인 검증 작업은 병렬로
wc -l file1.md &
wc -l file2.md &
wc -l file3.md &
wait

# 또는 Claude Code에서 Bash 도구를 여러 번 병렬 호출
```

---

## 세션 관리 전략

### Auto-compact 대비

```
Auto-compact가 발생하면 ~8K tokens의 요약 비용 발생.
이를 최소화하려면:

1. 불필요한 도구 결과를 줄여 컨텍스트 증가 속도 낮추기
2. 장기 세션보다 목적별 짧은 세션 선호
3. session-context.md에 중간 결과 저장
```

### 대규모 작업 분할

```
큰 작업 (예: 10개 파일 생성):

# ✅ 효율적 접근
1. 전체 계획 수립 (1 turn)
2. 독립 파일들 병렬 Agent 위임 (1 turn, 3-4개 병렬)
3. 의존성 있는 파일 순차 처리 (2-3 turns)
4. 검증 (1 turn)
→ 총 5-6 turns

# ❌ 비효율적 접근
1. 파일 하나씩 순차 생성 (10 turns)
2. 각 파일마다 Read-back 검증 (10 turns)
3. 문제 발견 시 수정 루프 (5-10 turns)
→ 총 25-30 turns
```

---

## 체크리스트

### 파일 작업 전

- [ ] 파일 읽기 전: 목적 확인 (전체 vs 부분 vs 줄 수만)
- [ ] 이미 읽은 파일인지 확인 (중복 읽기 방지)
- [ ] Read 대신 Grep/Glob으로 해결 가능한지 확인

### Agent 위임 시

- [ ] 프롬프트에 줄 수 예산 포함 ("450줄 이내")
- [ ] 파일 경로만 전달 (내용 복붙 금지)
- [ ] 독립 작업은 병렬 실행 가능한지 확인
- [ ] 결과 형식 지정 ("코드만", "요약만" 등)

### 파일 쓰기 후

- [ ] 검증은 `wc -l` + `head`/`tail`로만
- [ ] 전체 Read-back 하지 않기
- [ ] 문제 시 Edit로 부분 수정 (전체 Rewrite 아님)

### 검색 시

- [ ] WebSearch 3-4회 이내
- [ ] Grep/Glob 우선 사용 (Bash grep/find 금지)
- [ ] 구조적 탐색은 Explore agent 활용

### 세션 전반

- [ ] 동일 파일 2회 이상 읽기 여부 점검
- [ ] 도구 결과 최소화 원칙 준수
- [ ] `set -e` 환경에서 `((var++))` 대신 `$((var + 1))` 사용

---

## 참조 스킬

```
/dx-ai-agents              - AI 에이전트 거버넌스
/dx-ai-agents-orchestration - 멀티 에이전트 오케스트레이션
/llmops                     - LLM 운영, 프롬프트 관리
/dx-metrics                 - DORA, SPACE, DevEx 측정
```
